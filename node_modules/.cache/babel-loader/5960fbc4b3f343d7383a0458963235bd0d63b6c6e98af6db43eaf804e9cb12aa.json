{"ast":null,"code":"import { useCallback, useEffect, useMemo, useRef, useState, useSyncExternalStore } from 'react';\n// in memory fallback used then `localStorage` throws an error\nexport const inMemoryData = new Map();\nexport default function useLocalStorageState(key, options) {\n  // istanbul ignore next\n  if (useSyncExternalStore === undefined) {\n    throw new TypeError(`You are using React 17 or below. Install with \"npm install use-local-storage-state@17\".`);\n  }\n  const [defaultValue] = useState(options === null || options === void 0 ? void 0 : options.defaultValue);\n  // SSR support\n  // - on the server, return a constant value\n  // - this makes the implementation simpler and smaller because the `localStorage` object is\n  //   `undefined` on the server\n  if (typeof window === 'undefined') {\n    return [defaultValue, () => {}, {\n      isPersistent: true,\n      removeItem: () => {}\n    }];\n  }\n  const serializer = options === null || options === void 0 ? void 0 : options.serializer;\n  // disabling ESLint because the above if statement can be executed only on the server. the value\n  // of `window` can't change between calls.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useBrowserLocalStorageState(key, defaultValue, options === null || options === void 0 ? void 0 : options.storageSync, serializer === null || serializer === void 0 ? void 0 : serializer.parse, serializer === null || serializer === void 0 ? void 0 : serializer.stringify);\n}\nfunction useBrowserLocalStorageState(key, defaultValue, storageSync = true, parse = parseJSON, stringify = JSON.stringify) {\n  // store default value in localStorage:\n  // - initial issue: https://github.com/astoilkov/use-local-storage-state/issues/26\n  //   issues that were caused by incorrect initial and secondary implementations:\n  //   - https://github.com/astoilkov/use-local-storage-state/issues/30\n  //   - https://github.com/astoilkov/use-local-storage-state/issues/33\n  if (!inMemoryData.has(key) && defaultValue !== undefined && goodTry(() => localStorage.getItem(key)) === null) {\n    // reasons for `localStorage` to throw an error:\n    // - maximum quota is exceeded\n    // - under Mobile Safari (since iOS 5) when the user enters private mode\n    //   `localStorage.setItem()` will throw\n    // - trying to access localStorage object when cookies are disabled in Safari throws\n    //   \"SecurityError: The operation is insecure.\"\n    goodTry(() => localStorage.setItem(key, stringify(defaultValue)));\n  }\n  // we keep the `parsed` value in a ref because `useSyncExternalStore` requires a cached version\n  const storageValue = useRef({\n    item: null,\n    parsed: defaultValue\n  });\n  const value = useSyncExternalStore(useCallback(onStoreChange => {\n    const onChange = localKey => {\n      if (key === localKey) {\n        onStoreChange();\n      }\n    };\n    callbacks.add(onChange);\n    return () => {\n      callbacks.delete(onChange);\n    };\n  }, [key]),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  () => {\n    var _a;\n    const item = (_a = goodTry(() => localStorage.getItem(key))) !== null && _a !== void 0 ? _a : null;\n    if (inMemoryData.has(key)) {\n      storageValue.current = {\n        item,\n        parsed: inMemoryData.get(key)\n      };\n    } else if (item !== storageValue.current.item) {\n      let parsed;\n      try {\n        parsed = item === null ? defaultValue : parse(item);\n      } catch (_b) {\n        parsed = defaultValue;\n      }\n      storageValue.current = {\n        item,\n        parsed\n      };\n    }\n    return storageValue.current.parsed;\n  },\n  // istanbul ignore next\n  () => defaultValue);\n  const setState = useCallback(newValue => {\n    const value = newValue instanceof Function ? newValue(storageValue.current.parsed) : newValue;\n    // reasons for `localStorage` to throw an error:\n    // - maximum quota is exceeded\n    // - under Mobile Safari (since iOS 5) when the user enters private mode\n    //   `localStorage.setItem()` will throw\n    // - trying to access `localStorage` object when cookies are disabled in Safari throws\n    //   \"SecurityError: The operation is insecure.\"\n    try {\n      localStorage.setItem(key, stringify(value));\n      inMemoryData.delete(key);\n    } catch (_a) {\n      inMemoryData.set(key, value);\n    }\n    triggerCallbacks(key);\n  }, [key, stringify]);\n  // - syncs change across tabs, windows, iframes\n  // - the `storage` event is called only in all tabs, windows, iframe's except the one that\n  //   triggered the change\n  useEffect(() => {\n    if (!storageSync) {\n      return undefined;\n    }\n    const onStorage = e => {\n      if (e.storageArea === goodTry(() => localStorage) && e.key === key) {\n        triggerCallbacks(key);\n      }\n    };\n    window.addEventListener('storage', onStorage);\n    return () => window.removeEventListener('storage', onStorage);\n  }, [key, storageSync]);\n  return useMemo(() => [value, setState, {\n    isPersistent: value === defaultValue || !inMemoryData.has(key),\n    removeItem() {\n      goodTry(() => localStorage.removeItem(key));\n      inMemoryData.delete(key);\n      triggerCallbacks(key);\n    }\n  }], [key, setState, value, defaultValue]);\n}\n// notifies all instances using the same `key` to update\nconst callbacks = new Set();\nfunction triggerCallbacks(key) {\n  for (const callback of [...callbacks]) {\n    callback(key);\n  }\n}\n// a wrapper for `JSON.parse()` that supports \"undefined\" value. otherwise,\n// `JSON.parse(JSON.stringify(undefined))` returns the string \"undefined\" not the value `undefined`\nfunction parseJSON(value) {\n  return value === 'undefined' ? undefined : JSON.parse(value);\n}\nfunction goodTry(tryFn) {\n  try {\n    return tryFn();\n  } catch (_a) {\n    return undefined;\n  }\n}","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","useState","useSyncExternalStore","inMemoryData","Map","useLocalStorageState","key","options","undefined","TypeError","defaultValue","window","isPersistent","removeItem","serializer","useBrowserLocalStorageState","storageSync","parse","stringify","parseJSON","JSON","has","goodTry","localStorage","getItem","setItem","storageValue","item","parsed","value","onStoreChange","onChange","localKey","callbacks","add","delete","_a","current","get","_b","setState","newValue","Function","set","triggerCallbacks","onStorage","e","storageArea","addEventListener","removeEventListener","Set","callback","tryFn"],"sources":["/Users/mukaddes.uzdoganlar/Challenges/Recap-Project-4/node_modules/use-local-storage-state/src/useLocalStorageState.js"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState, useSyncExternalStore } from 'react';\n// in memory fallback used then `localStorage` throws an error\nexport const inMemoryData = new Map();\nexport default function useLocalStorageState(key, options) {\n    // istanbul ignore next\n    if (useSyncExternalStore === undefined) {\n        throw new TypeError(`You are using React 17 or below. Install with \"npm install use-local-storage-state@17\".`);\n    }\n    const [defaultValue] = useState(options === null || options === void 0 ? void 0 : options.defaultValue);\n    // SSR support\n    // - on the server, return a constant value\n    // - this makes the implementation simpler and smaller because the `localStorage` object is\n    //   `undefined` on the server\n    if (typeof window === 'undefined') {\n        return [\n            defaultValue,\n            () => { },\n            {\n                isPersistent: true,\n                removeItem: () => { },\n            },\n        ];\n    }\n    const serializer = options === null || options === void 0 ? void 0 : options.serializer;\n    // disabling ESLint because the above if statement can be executed only on the server. the value\n    // of `window` can't change between calls.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useBrowserLocalStorageState(key, defaultValue, options === null || options === void 0 ? void 0 : options.storageSync, serializer === null || serializer === void 0 ? void 0 : serializer.parse, serializer === null || serializer === void 0 ? void 0 : serializer.stringify);\n}\nfunction useBrowserLocalStorageState(key, defaultValue, storageSync = true, parse = parseJSON, stringify = JSON.stringify) {\n    // store default value in localStorage:\n    // - initial issue: https://github.com/astoilkov/use-local-storage-state/issues/26\n    //   issues that were caused by incorrect initial and secondary implementations:\n    //   - https://github.com/astoilkov/use-local-storage-state/issues/30\n    //   - https://github.com/astoilkov/use-local-storage-state/issues/33\n    if (!inMemoryData.has(key) &&\n        defaultValue !== undefined &&\n        goodTry(() => localStorage.getItem(key)) === null) {\n        // reasons for `localStorage` to throw an error:\n        // - maximum quota is exceeded\n        // - under Mobile Safari (since iOS 5) when the user enters private mode\n        //   `localStorage.setItem()` will throw\n        // - trying to access localStorage object when cookies are disabled in Safari throws\n        //   \"SecurityError: The operation is insecure.\"\n        goodTry(() => localStorage.setItem(key, stringify(defaultValue)));\n    }\n    // we keep the `parsed` value in a ref because `useSyncExternalStore` requires a cached version\n    const storageValue = useRef({\n        item: null,\n        parsed: defaultValue,\n    });\n    const value = useSyncExternalStore(useCallback((onStoreChange) => {\n        const onChange = (localKey) => {\n            if (key === localKey) {\n                onStoreChange();\n            }\n        };\n        callbacks.add(onChange);\n        return () => {\n            callbacks.delete(onChange);\n        };\n    }, [key]), \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    () => {\n        var _a;\n        const item = (_a = goodTry(() => localStorage.getItem(key))) !== null && _a !== void 0 ? _a : null;\n        if (inMemoryData.has(key)) {\n            storageValue.current = {\n                item,\n                parsed: inMemoryData.get(key),\n            };\n        }\n        else if (item !== storageValue.current.item) {\n            let parsed;\n            try {\n                parsed = item === null ? defaultValue : parse(item);\n            }\n            catch (_b) {\n                parsed = defaultValue;\n            }\n            storageValue.current = {\n                item,\n                parsed,\n            };\n        }\n        return storageValue.current.parsed;\n    }, \n    // istanbul ignore next\n    () => defaultValue);\n    const setState = useCallback((newValue) => {\n        const value = newValue instanceof Function ? newValue(storageValue.current.parsed) : newValue;\n        // reasons for `localStorage` to throw an error:\n        // - maximum quota is exceeded\n        // - under Mobile Safari (since iOS 5) when the user enters private mode\n        //   `localStorage.setItem()` will throw\n        // - trying to access `localStorage` object when cookies are disabled in Safari throws\n        //   \"SecurityError: The operation is insecure.\"\n        try {\n            localStorage.setItem(key, stringify(value));\n            inMemoryData.delete(key);\n        }\n        catch (_a) {\n            inMemoryData.set(key, value);\n        }\n        triggerCallbacks(key);\n    }, [key, stringify]);\n    // - syncs change across tabs, windows, iframes\n    // - the `storage` event is called only in all tabs, windows, iframe's except the one that\n    //   triggered the change\n    useEffect(() => {\n        if (!storageSync) {\n            return undefined;\n        }\n        const onStorage = (e) => {\n            if (e.storageArea === goodTry(() => localStorage) && e.key === key) {\n                triggerCallbacks(key);\n            }\n        };\n        window.addEventListener('storage', onStorage);\n        return () => window.removeEventListener('storage', onStorage);\n    }, [key, storageSync]);\n    return useMemo(() => [\n        value,\n        setState,\n        {\n            isPersistent: value === defaultValue || !inMemoryData.has(key),\n            removeItem() {\n                goodTry(() => localStorage.removeItem(key));\n                inMemoryData.delete(key);\n                triggerCallbacks(key);\n            },\n        },\n    ], [key, setState, value, defaultValue]);\n}\n// notifies all instances using the same `key` to update\nconst callbacks = new Set();\nfunction triggerCallbacks(key) {\n    for (const callback of [...callbacks]) {\n        callback(key);\n    }\n}\n// a wrapper for `JSON.parse()` that supports \"undefined\" value. otherwise,\n// `JSON.parse(JSON.stringify(undefined))` returns the string \"undefined\" not the value `undefined`\nfunction parseJSON(value) {\n    return value === 'undefined' ? undefined : JSON.parse(value);\n}\nfunction goodTry(tryFn) {\n    try {\n        return tryFn();\n    }\n    catch (_a) {\n        return undefined;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}